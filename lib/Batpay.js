const BigNumber = global.web3.utils.BN
const merkle = require('../lib/merkle')
const abi = require('ethereumjs-abi')

const bytesPerId = 4
const NEW_ACCOUNT_FLAG = new BigNumber(new BigNumber(2)).pow(new BigNumber(256)).sub(new BigNumber(1))
const prefs = {
  default: {
    maxBulk: 5000,
    maxTransfer: 5000,
    challengeBlocks: 5,
    challengeStepBlocks: 5,
    collectStake: 500,
    challengeStake: 100,
    unlockBlocks: 5,
    maxCollectAmount: 1000000
  },
  testing: {
    maxBulk: 5000,
    maxTransfer: 5000,
    challengeBlocks: 15,
    challengeStepBlocks: 5,
    collectStake: 500,
    challengeStake: 100,
    unlockBlocks: 15,
    maxCollectAmount: 1000000
  },
  recommended: {
    maxBulk: 5000,
    maxTransfer: 5000,
    challengeBlocks: 240,
    challengeStepBlocks: 40,
    collectStake: 1000000,
    challengeStake: 100000,
    unlockBlocks: 60,
    maxCollectAmount: 1000000
  }
}

/**
 * BP is a wrapper providing a simplified interface to BatPay smart contracts.
 */
class BP {
  /**
   * Constructor takes two instances of a already deployed TruffleContract, one
   * for BatPay and the other for the token to be handled by BatPay.
   * @param {TruffleContract} bp - BatPay TruffleContract instance.
   * @param {TruffleContract} token Token TruffleContract instance.
   */
  constructor (bp, token) {
    this.bp = bp
    this.st = token
    this.payments = {}
    this.payList = {}
    this.bulkPayList = {}
    this.accountList = {}
    // `ids` is a dictionary of { accountId: EthereumAddress }.
    this.ids = {}
  }

  /**
   * Initialize BP to BatPay's contract config.
   */
  async init () {
    let params = await this.bp.params.call()
    this.maxBulk = params[0].toNumber()
    this.maxTransfer = params[1].toNumber()
    this.challengeBlocks = params[2].toNumber()
    this.challengeStepBlocks = params[3].toNumber()
    this.collectStake = params[4].toNumber()
    this.challengeStake = params[5].toNumber()
    this.unlockBlocks = params[6].toNumber()
    this.maxCollectAmount = params[13].toNumber()
    this.INSTANT_SLOT = (await this.bp.INSTANT_SLOT.call()).toNumber()
  }

  /**
   * Register a new account in the name of `address`.
   * @param {string} address Ethereum adderess owner of the newly created account.
   * @return {[id, tx_receipt]}
   */
  async registerAccount (address) {
    let t = await this.bp.register({ from: address })
    let recp = await t.receipt

    let log = findEvent(t.logs, 'AccountRegistered')
    let id = log.accountId.toNumber()
    this.ids[id] = address

    return [ id, recp ]
  }

  /**
   * Reserve a list of accounts and generate the proof that will be later be
   * used to claim the accounts.
   * @param {string[]} addresses List of addresses to be registered.
   */
  async bulkRegister (addresses) {
    let bulkSize = addresses.length
    // Use the addresses list to build a Merkle tree that will later be used as proof.
    let tree = merkle.merkle(addresses)

    // Reserve accounts and provide the hash of the root of the Merkle tree.
    // This hash will later be used to verify the identity of the claimer of
    // the accounts reserved.
    let tx = await this.bp.bulkRegister(bulkSize, tree.roothash)
    let recp = await tx.receipt
    let bulkRegisterLog = findEvent(tx.logs, 'BulkRegister')
    let smallestAccountId = bulkRegisterLog.smallestAccountId.toNumber()
    let bulkId = bulkRegisterLog.bulkId.toNumber()

    // Save accountIds and their corresponding addresses.
    for (let i = 0; i < addresses.length; i++) {
      this.ids[smallestAccountId + i] = addresses[i]
    }

    return { tree, smallestAccountId, bulkId, recp }
  }

  /**
   * Finish registration of an account and claim it, providing the Merkle tree
   * generated by `bulkRegister`.
   * @param {object} bulk object containing the merkle tree, the
   * smallestAccountId and the bulkId generated by `bulkRegister`.
   * @param {string} address account owner
   * @param {number} accountId Id of the account to be registered
   */
  async claimBulkRegistrationId (bulk, address, accountId) {
    let i = accountId - bulk.smallestAccountId
    let proof = merkle.getProof(bulk.tree, i)
    proof = proof.map(x => x.v)
    let tx = await this.bp.claimBulkRegistrationId(address, proof, accountId, bulk.bulkId)
    let recp = await tx.receipt
    let log = findEvent(tx.logs, 'AccountRegistered')

    return [log.accountId, log.accountAddress, recp]
  }

  /**
   * Fund BatPay contract.
   * Approve an ERC20 token transfer and transfer those tokens to the BatPay
   * contract.
   * @param {number} amount amount of tokens
   * @param {number} accountId tokens owner
   * @param {string} from address issuing the transaction
   */
  async deposit (amount, accountId, from) {
    let addr = from || this.ids[accountId]
    let nid = accountId

    let t1 = await this.st.approve(this.bp.address, amount, { from: addr })
    await t1.receipt

    let t2 = await this.bp.deposit(amount, accountId, { from: addr })
    await t2.receipt

    if (accountId == -1) {
      let log = findEvent(t2.logs, 'AccountRegistered')
      nid = log.accountId.toNumber()
      this.ids[nid] = from
    }
    return [nid, t1.receipt, t2.receipt]
  }

  /**
   * Register a new payment to multiple account IDs.
   * @param {number} fromAccountId Account to debit funds from.
   * @param {number} amount Tokens to pay to each destination.
   * @param {number} fee Tokens to be payed to the party providing the unlocking service.
   * @param {number[]} payeesAccountsIds List of account ids to pay `amount` to.
   * @param {string} lockingKeyHash hash of (unlockerAccountId, unlocker's secret key).
   *            See `utils.hashLock`.
   */
  async registerPayment ({ fromAccountId, amount, unlockerFee, payeesAccountsIds, lockingKeyHash } = {}) {
    // Build a gas-efficient representation of the destination accounts list.
    const payData = getPayData(payeesAccountsIds)

    const tx = await this.bp.registerPayment(fromAccountId, amount, unlockerFee, payData, 0, 0, lockingKeyHash, 0)

    const payIndex = (await this.bp.getPaymentsLength.call()) - 1
    this.payments[payIndex] = amount
    this.payList[payIndex] = payeesAccountsIds
    payeesAccountsIds.forEach(payeeAccountId => {
      if (this.accountList[payeeAccountId] === undefined) {
        this.accountList[payeeAccountId] = []
      }
      this.accountList[payeeAccountId].push(payIndex)
    })

    return [payIndex, tx.receipt]
  }

  async registerPaymentWithBulk (from, amount, fee, list, bulkList, lockingKeyHash) {
    let data = getPayData(list)

    let nbulk = bulkList.length
    let tree = merkle.merkle(bulkList)

    let tx = await this.bp.registerPayment(from, amount, fee, data, nbulk, tree.roothash, lockingKeyHash, 0)
    let recp = await tx.receipt

    let z = findEvent(tx.logs, 'BulkRegister')

    let smallestAccountId = z.smallestAccountId.toNumber()
    let bulkId = z.bulkId.toNumber()
    let payIndex = (await this.bp.getPaymentsLength.call()) - 1

    for (let i = 0; i < bulkList.length; i++) {
      let j = smallestAccountId + i

      this.ids[j] = bulkList[i]

      if (this.accountList[j] == undefined) {
        this.accountList[j] = []
      }
      this.accountList[j].push(payIndex)
    }

    this.payments[payIndex] = amount
    this.payList[payIndex] = list
    this.bulkPayList[payIndex] = bulkList

    list.forEach(x => {
      if (this.accountList[x] == undefined) {
        this.accountList[x] = []
      }
      this.accountList[x].push(payIndex)
    })

    return [ payIndex, { tree, smallestAccountId, bulkId }, tx.receipt]
  }

  /**
   * Unlock a previously registered payment, while revealing the key used to
   * lock the payment.
   * Unlocking the payment and revealing the key atomically allows for the
   * trustless exchange of digital goods (if the same key was previously used
   * to encrypt such digital goods).
   * @param {number} payIndex Payment index returned by `registerPayment`
   * @param {number} unlockerAccountId ID of the party providing the unlocking service.
   * @param {string} key Key used to generate the lockingKeyHash when the payment
   *                 was registered.
   */
  async unlock (payIndex, unlockerAccountId, key) {
    let t = await this.bp.unlock(payIndex, unlockerAccountId, key)
    return await t.receipt
  }

  async refundLockedPayment (payIndex) {
    let t = await this.bp.refundLockedPayment(payIndex)
    return await t.receipt
  }

  /**
   * Collect a batch of registered payments between two payment IDs.
   * @param {nulmber} delegate ID of the account performing the collect operation on
   *                  behalf of the user.
   * @param {number} slot ID of the slot that will be used for the challenge game.
   * @param {number} toAccountId Payee account ID.
   * @param {number} fromPaymentId lowest payment ID to collect.
   * @param {number} toPaymentId highest payment ID to collect.
   * @param {number} amount sum of tokens corresponding to the payments between
   *            `fromPaymentId` and `toPaymentId`.
   * @param {number} fee Fee to be payed to the delegate.
   * @param {string} address Address to transfer the funds to.
   */
  async collect ({ delegate, slot, toAccountId, fromPaymentId, toPaymentId, amount, fee, address } = {}) {
    let signature = await signCollect(this.ids[toAccountId], this.bp.address, delegate, toAccountId, fromPaymentId, toPaymentId, amount, fee, address)

    let tx = await this.bp.collect(delegate, slot, toAccountId, toPaymentId, amount, fee, address, signature)
    return tx
  }

  async freeSlot (delegate, slot) {
    let tx = await this.bp.freeSlot(delegate, slot)
    return await tx.receipt
  }

  async challenge_1 (delegate, slot, challenger) {
    let tx = await this.bp.challenge_1(delegate, slot, challenger, { from: this.ids[challenger] })
    return await tx.receipt
  }

  async challenge_2 (delegate, slot, data) {
    let tx = await this.bp.challenge_2(delegate, slot, data, { from: this.ids[delegate] })
    return await tx.receipt
  }

  async challenge_3 (delegate, slot, data, index, challenger) {
    let tx = await this.bp.challenge_3(delegate, slot, data, index, { from: this.ids[challenger] })
    return await tx.receipt
  }

  async challenge_4 (delegate, slot, payData) {
    let tx = await this.bp.challenge_4(delegate, slot, payData, { from: this.ids[delegate] })
    return await tx.receipt
  }

  async challenge_failed (delegate, slot) {
    let tx = await this.bp.challenge_failed(delegate, slot, { from: this.ids[delegate] })
    return await tx.receipt
  }

  async challenge_success (delegate, slot, challenger) {
    let tx = await this.bp.challenge_success(delegate, slot, { from: this.ids[challenger] })
    return await tx.receipt
  }

  async balanceOf (id) {
    let balance = await this.bp.balanceOf.call(id)
    return balance
  }

  async tokenBalance (addr) {
    let balance = await this.st.balanceOf.call(addr)
    return balance
  }

  async tokenTransfer (from, to, amount) {
    let tx = await this.st.transfer(to, amount, { from: from })
    let recp = await tx.receipt

    return recp
  }

  async getAccount (id) {
    return await this.bp.accounts.call(id)
  }

  async getCollectedIndex (accountId) {
    let account = await this.getAccount(accountId)
    return account[2].toNumber()
  }

  async getCollectAmount (id, fromIndex, toIndex) {
    let v = this.accountList[id]
    if (v == undefined) return 0
    let amount = 0
    v.forEach(x => {
      if (x < fromIndex || x >= toIndex) return
      amount += this.payments[x]
    })
    return amount
  }

  getCollectData (id, fromIndex, toIndex) {
    let v = this.accountList[id]
    let w = []
    if (v == undefined) return 0
    let amount = 0
    w = v.filter(x => x >= fromIndex && x < toIndex)

    return w
  }

  getPayList (payIndex) {
    return this.payList[payIndex]
  }

  async getPaymentsLength () {
    return (await this.bp.getPaymentsLength.call())
  }

  async showBalance () {
    console.log(' '.repeat(66))
    let accounts = []
    for (let i = 0; i < 10; i++) {
      const [addr, balance, lastCollectedPaymentId] = await this.getAccount(i)
      const tokenBalance = await this.tokenBalance(this.ids[i])
      accounts.push({
        'Account ID': i,
        'Token balance': tokenBalance.toNumber(),
        'Token balance (deposited in BatPay)': balance.toNumber(),
        'Last collected payment ID': lastCollectedPaymentId.toNumber(),
        'Address': addr
      })
    }
    console.table(accounts)
    console.log()
  }
}

function findEvent (array, eventName) {
  let x = array.find(ev => ev.event == eventName)
  if (x) return x.args
  throw new Error(eventName + ' not found')
}

function hex (x) {
  return ('00' + x.toString(16)).substr(-2)
}

function hexStr (n, len) {
  let s = n.toString(16)
  while (s.length < len * 2) s = '0' + s
  return s
}

function toLeftPaddedBytes32 (value) {
  const h = value.toString(16)
  const b = ('0000000000000000000000000000000000000000000000000000000000000000' + h).substr(-64)
  return `0x${b}`
}

function item (amount, index) {
  return hexStr(amount, 8) + hexStr(index, 4)
}

function getChallengeData (amounts, indexes) {
  let data = '0x'
  for (let i = 0; i < amounts.length && i < indexes.length; i++) { data = data + item(amounts[i], indexes[i]) }

  return data
}

function getPayData (list) {
  list.sort((a, b) => a - b)

  var last = 0
  var data = ''

  for (let i = 0; i < list.length; i++) {
    let delta = list[i] - last

    let number = ''
    for (let j = 0; j < bytesPerId; j++) {
      number = hex(delta % 256) + number
      delta = Math.trunc(delta / 256)
    }

    data = data + number
    last = list[i]
  }

  return new web3.utils.BN('0xff' + hex(bytesPerId) + data)
}

function hashLock (unlocker, key) {
  let hash = abi.soliditySHA3(['uint32', 'bytes'], [unlocker, Buffer.from(key, 'utf8')]).toString('hex')
  return '0x' + hash
}

function hashCollect (instance, delegate, toId, fromPayIndex, toPayIndex, amount, fee, addr) {
  let hash = abi.soliditySHA3(
    ['address', 'uint32', 'uint32', 'uint32', 'uint32', 'uint64', 'uint64', 'address'],
    [instance, delegate, toId, fromPayIndex, toPayIndex, amount, fee, addr]).toString('hex')

  return '0x' + hash
}

async function signCollect (account, instance, delegate, toId, fromPayIndex, toPayIndex, amount, fee, addr) {
  let hash = hashCollect(instance, delegate, toId, fromPayIndex, toPayIndex, amount, fee, addr)

  // asyncSign is necessary because web3-provider-engine does not support
  // synchronous requests
  const asyncSign = (account, hash) => new Promise((resolve, reject) => {
    web3.eth.sign(account, hash, (err, result) => {
      if (err) {
        return reject(err)
      }
      resolve(result)
    })
  })

  return asyncSign(account, hash)
}

module.exports = {
  NEW_ACCOUNT_FLAG,
  BP,
  findEvent,
  getChallengeData,
  prefs,
  toLeftPaddedBytes32
}
